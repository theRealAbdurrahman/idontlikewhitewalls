/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Meetball API
 * API for Meetball - The Summeet's event networking platform
 * OpenAPI spec version: 0.1.0
 */
import Axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import { useMutation, useQuery, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { apiConfig, shouldLogApiRequests } from '../config/api';

/**
 * Configure axios instance with base URL and interceptors
 */
const axiosInstance = Axios.create({
  baseURL: apiConfig.baseURL,
  timeout: apiConfig.timeout,
  headers: apiConfig.headers,
});

// Request interceptor for debugging in development
if (shouldLogApiRequests) {
  axiosInstance.interceptors.request.use(
    (config) => {
      console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`, {
        data: config.data,
        params: config.params,
      });
      return config;
    },
    (error) => {
      console.error('‚ùå API Request Error:', error);
      return Promise.reject(error);
    }
  );

  // Response interceptor for debugging in development
  axiosInstance.interceptors.response.use(
    (response) => {
      console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`, response.data);
      return response;
    },
    (error) => {
      console.error('‚ùå API Response Error:', error.response?.status, error.response?.data);
      return Promise.reject(error);
    }
  );
}

/**
 * Custom axios instance for API calls
 */
export const customInstance = <T>(config: AxiosRequestConfig): Promise<AxiosResponse<T>> => {
  return axiosInstance({
    ...config,
  });
};

// Type definitions for API models
export type AnswerCreate = import('./models').AnswerCreate;
export type AnswerRead = import('./models').AnswerRead;
export type AnswerUpdate = import('./models').AnswerUpdate;
export type EventCreate = import('./models').EventCreate;
export type EventRead = import('./models').EventRead;
export type EventUpdate = import('./models').EventUpdate;
export type EventParticipantCreate = import('./models').EventParticipantCreate;
export type EventParticipantRead = import('./models').EventParticipantRead;
export type EventParticipantUpdate = import('./models').EventParticipantUpdate;
export type InteractionCreate = import('./models').InteractionCreate;
export type InteractionRead = import('./models').InteractionRead;
export type InteractionUpdate = import('./models').InteractionUpdate;
export type QuestionCreate = import('./models').QuestionCreate;
export type QuestionRead = import('./models').QuestionRead;
export type QuestionUpdate = import('./models').QuestionUpdate;
export type UserCreate = import('./models').UserCreate;
export type UserRead = import('./models').UserRead;
export type UserUpdate = import('./models').UserUpdate;

/**
 * User Profile interface matching the API response structure
 * This represents the detailed user profile response from /api/v1/users/[user_id]
 */
export interface UserProfile {
  id: string;
  linkedin_url: string | null;
  auth_id: string;
  email: string;
  first_name: string;
  last_name: string;
  profile_picture: string | null;
  bio: string | null;
  title: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  last_active_at: string | null;
  connectDetails: string | null; //  connect details (not in API yet)
}

/**
 * Fetch a single user profile by ID from the API
 * @param userId - The unique identifier for the user
 * @returns Promise resolving to the user profile data
 */
export const fetchUserProfile = async (userId: string): Promise<UserProfile> => {
  if (!userId || userId.trim() === '') {
    throw new Error('User ID is required');
  }

  try {
    const response = await customInstance<UserProfile>({
      url: `/api/v1/users/${encodeURIComponent(userId)}`,
      method: 'GET',
    });

    return response.data;
  } catch (error: any) {
    // Enhanced error handling with specific error messages
    if (error?.response?.status === 404) {
      throw new Error('User profile not found');
    } else if (error?.response?.status === 403) {
      throw new Error('Access denied to user profile');
    } else if (error?.response?.status === 401) {
      throw new Error('Authentication required');
    } else if (error?.response?.status >= 500) {
      throw new Error('Server error occurred while fetching profile');
    } else if (!navigator.onLine) {
      throw new Error('No internet connection');
    } else {
      throw new Error(error?.message || 'Failed to fetch user profile');
    }
  }
};

/**
 * Interface for current user data from Logto
 */
export interface LogtoUserData {
  sub: string;
  email?: string;
  name?: string;
  given_name?: string;
  family_name?: string;
  picture?: string;
  bio?: string;
  job_title?: string;
  linkedin_url?: string;
}

/**
 * Get or create current user from Logto authentication data
 * @param logtoData - User data from Logto authentication
 * @returns Promise resolving to the backend user profile
 */
export const fetchCurrentUser = async (logtoData: LogtoUserData): Promise<UserProfile> => {
  if (!logtoData.sub) {
    throw new Error('Logto sub (user ID) is required');
  }

  try {
    // Prepare request body with user data
    const requestBody = {
      logto_sub: logtoData.sub,
      email: logtoData.email,
      given_name: logtoData.given_name,
      family_name: logtoData.family_name,
      picture: logtoData.picture,
      bio: logtoData.bio,
      job_title: logtoData.job_title,
      linkedin_url: logtoData.linkedin_url,
    };

    // If no name parts, try to parse from name field
    if (!logtoData.given_name && !logtoData.family_name && logtoData.name) {
      const nameParts = logtoData.name.split(' ');
      if (nameParts.length > 0) {
        requestBody.given_name = nameParts[0];
        if (nameParts.length > 1) {
          requestBody.family_name = nameParts.slice(1).join(' ');
        }
      }
    }

    const response = await customInstance<UserProfile>({
      url: `/api/v1/users/me`,
      method: 'POST',
      data: requestBody,
    });

    return response.data;
  } catch (error: any) {
    // Enhanced error handling
    if (error?.response?.status === 400) {
      throw new Error('Invalid user data provided');
    } else if (error?.response?.status === 500) {
      throw new Error('Server error occurred while creating/fetching user');
    } else if (!navigator.onLine) {
      throw new Error('No internet connection');
    } else {
      throw new Error(error?.message || 'Failed to get current user');
    }
  }
};

/**
 * React Query hook for fetching user profile data
 * @param userId - The unique identifier for the user
 * @param options - Optional React Query configuration
 * @returns React Query result with user profile data, loading state, and error handling
 */
export const useUserProfile = (
  userId: string | undefined,
  options?: Omit<UseQueryOptions<UserProfile, Error>, 'queryKey' | 'queryFn'>
) => {
  return useQuery<UserProfile, Error>({
    queryKey: ['userProfile', userId],
    queryFn: () => {
      if (!userId) {
        throw new Error('User ID is required');
      }
      return fetchUserProfile(userId);
    },
    enabled: !!userId && userId.trim() !== '', // Only run query if userId is provided and not empty
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep in cache for 30 minutes
    retry: (failureCount, error: any) => {
      // Don't retry on 404 (user not found) or 403 (access denied)
      if (error?.message?.includes('not found') || error?.message?.includes('Access denied')) {
        return false;
      }
      // Retry up to 3 times for other errors
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
    ...options,
  });
};

// API function signatures
export const readEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: EventRead[] }>> => {
  return customInstance<{ data: EventRead[] }>({
    url: '/api/v1/events',
    method: 'GET',
    params,
    ...options,
  });
};

export const createEventApiV1EventsPost = (
  data: EventCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventRead>> => {
  return customInstance<EventRead>({
    url: '/api/v1/events',
    method: 'POST',
    data,
    ...options,
  });
};

export const readQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: QuestionRead[] }>> => {
  return customInstance<{ data: QuestionRead[] }>({
    url: '/api/v1/questions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createQuestionApiV1QuestionsPost = (
  data: QuestionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<QuestionRead>> => {
  return customInstance<QuestionRead>({
    url: '/api/v1/questions',
    method: 'POST',
    data,
    ...options,
  });
};

export const createInteractionApiV1InteractionsPost = (
  data: InteractionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<InteractionRead>> => {
  return customInstance<InteractionRead>({
    url: '/api/v1/interactions',
    method: 'POST',
    data,
    ...options,
  });
};

export const deleteInteractionApiV1InteractionsInteractionIdDelete = (
  interactionId: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/interactions/${interactionId}`,
    method: 'DELETE',
    ...options,
  });
};

export const readInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: InteractionRead[] }>> => {
  return customInstance<{ data: InteractionRead[] }>({
    url: '/api/v1/interactions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createEventParticipantApiV1EventParticipantsPost = (
  data: EventParticipantCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventParticipantRead>> => {
  return customInstance<EventParticipantRead>({
    url: '/api/v1/event-participants',
    method: 'POST',
    data,
    ...options,
  });
};

export const readAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: AnswerRead[] }>> => {
  return customInstance<{ data: AnswerRead[] }>({
    url: '/api/v1/answers',
    method: 'GET',
    params,
    ...options,
  });
};

export const createAnswerApiV1AnswersPost = (
  data: AnswerCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnswerRead>> => {
  return customInstance<AnswerRead>({
    url: '/api/v1/answers',
    method: 'POST',
    data,
    ...options,
  });
};

export const readUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: UserRead[] }>> => {
  return customInstance<{ data: UserRead[] }>({
    url: '/api/v1/users',
    method: 'GET',
    params,
    ...options,
  });
};

export const createUserApiV1UsersPost = (
  data: UserCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UserRead>> => {
  return customInstance<UserRead>({
    url: '/api/v1/users',
    method: 'POST',
    data,
    ...options,
  });
};

// React Query hooks
export const useReadEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: EventRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['events', params],
    queryFn: () => readEventsApiV1EventsGet(params),
    ...options,
  });
};

export const useReadQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: QuestionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['questions', params],
    queryFn: () => readQuestionsApiV1QuestionsGet(params),
    ...options,
  });
};

export const useReadInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: InteractionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['interactions', params],
    queryFn: () => readInteractionsApiV1InteractionsGet(params),
    ...options,
  });
};

export const useCreateQuestionApiV1QuestionsPost = (
  options?: UseMutationOptions<AxiosResponse<QuestionRead>, Error, { data: QuestionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createQuestionApiV1QuestionsPost(data),
    ...options,
  });
};

export const useCreateInteractionApiV1InteractionsPost = (
  options?: UseMutationOptions<AxiosResponse<InteractionRead>, Error, { data: InteractionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createInteractionApiV1InteractionsPost(data),
    ...options,
  });
};

export const useDeleteInteractionApiV1InteractionsInteractionIdDelete = (
  options?: UseMutationOptions<AxiosResponse<void>, Error, { interactionId: string }>
) => {
  return useMutation({
    mutationFn: ({ interactionId }) => deleteInteractionApiV1InteractionsInteractionIdDelete(interactionId),
    ...options,
  });
};

export const useCreateEventParticipantApiV1EventParticipantsPost = (
  options?: UseMutationOptions<AxiosResponse<EventParticipantRead>, Error, { data: EventParticipantCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventParticipantApiV1EventParticipantsPost(data),
    ...options,
  });
};

export const useCreateEventApiV1EventsPost = (
  options?: UseMutationOptions<AxiosResponse<EventRead>, Error, { data: EventCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventApiV1EventsPost(data),
    ...options,
  });
};

export const useCreateAnswerApiV1AnswersPost = (
  options?: UseMutationOptions<AxiosResponse<AnswerRead>, Error, { data: AnswerCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createAnswerApiV1AnswersPost(data),
    ...options,
  });
};

export const useCreateUserApiV1UsersPost = (
  options?: UseMutationOptions<AxiosResponse<UserRead>, Error, { data: UserCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createUserApiV1UsersPost(data),
    ...options,
  });
};

export const useReadAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: AnswerRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['answers', params],
    queryFn: () => readAnswersApiV1AnswersGet(params),
    ...options,
  });
};

export const useReadUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: UserRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => readUsersApiV1UsersGet(params),
    ...options,
  });
};