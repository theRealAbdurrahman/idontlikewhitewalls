/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Meetball API
 * API for Meetball - The Summeet's event networking platform
 * OpenAPI spec version: 0.1.0
 */
import Axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import { useMutation, useQuery, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { apiConfig, shouldLogApiRequests } from '../config/api';
import { UserProfileApiResponse, UserProfileResponse } from '../models';
import { isWebcontainerEnv, getMockToken } from '../utils/webcontainer';

// Global token accessor - will be set by AuthProvider
let globalGetAccessToken: (() => Promise<string | null>) | null = null;

/**
 * Set the global access token getter function
 * This will be called by AuthProvider when it initializes
 */
export const setGlobalAccessTokenGetter = (getter: () => Promise<string | null>) => {
  globalGetAccessToken = getter;
};

/**
 * Configure axios instance with base URL and interceptors
 */
const axiosInstance = Axios.create({
  baseURL: apiConfig.baseURL,
  timeout: apiConfig.timeout,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Enhanced request interceptor for authentication and debugging
axiosInstance.interceptors.request.use(
  async (config) => {
    console.log(`üöÄ API Request interceptor for: ${config.method?.toUpperCase()} ${config.url}`);
    console.log('üîç Current headers:', config.headers);
    console.log('üîç globalGetAccessToken available:', !!globalGetAccessToken);
    console.log('üîç isWebcontainerEnv:', isWebcontainerEnv());

  // Handle webcontainer environment first
    if (isWebcontainerEnv() && !config.headers?.Authorization) {
      const mockToken = getMockToken();
      config.headers = config.headers || {};
      config.headers.Authorization = `Bearer ${mockToken}`;
      console.log('üîß Webcontainer: Injected mock auth token');
    } 
    // Handle real authentication for non-webcontainer environments
    else if (!isWebcontainerEnv() && globalGetAccessToken && !config.headers?.Authorization) {
      try {
        console.log('üîê Attempting to get access token...');
        const token = await globalGetAccessToken();
        if (token) {
          config.headers = config.headers || {};
          config.headers.Authorization = `Bearer ${token}`;
          console.log('üîê Auth: Injected real access token');
        } else {
          console.warn('‚ö†Ô∏è Auth: No access token available');
        }
      } catch (error) {
        console.error('‚ùå Auth: Failed to get access token:', error);
        // Continue with request even if token fetch fails
        // The backend will handle unauthorized requests appropriately
      }
    } else {
      console.log('üîç Skipping token injection:', {
        isWebcontainer: isWebcontainerEnv(),
        hasGlobalGetAccessToken: !!globalGetAccessToken,
        hasExistingAuth: !!config.headers?.Authorization
      });
    }

    console.log('üîç Final headers:', config.headers);

    // Debug logging in development
    if (shouldLogApiRequests) {
      console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`, {
        data: config.data,
        params: config.params,
        headers: {
          ...config.headers,
          Authorization: config.headers?.Authorization ? '[REDACTED]' : undefined,
        },
      });
    }
    
    return config;
  },
  (error) => {
    console.error('‚ùå API Request Error:', error);
    return Promise.reject(error);
  }
);

// Enhanced response interceptor for token refresh and error handling
axiosInstance.interceptors.response.use(
  (response) => {
    if (shouldLogApiRequests) {
      console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`, response.data);
    }
    return response;
  },
  async (error) => {
    const originalRequest = error.config;

    // Handle 401 Unauthorized responses
    if (error.response?.status === 401 && !originalRequest._retry) {
      console.warn('üîÑ Auth: Received 401, attempting token refresh...');
      originalRequest._retry = true;

      if (!isWebcontainerEnv() && globalGetAccessToken) {
        try {
          // Try to get a fresh token
          const newToken = await globalGetAccessToken();
          if (newToken) {
            originalRequest.headers.Authorization = `Bearer ${newToken}`;
            console.log('üîê Auth: Retrying request with refreshed token');
            return axiosInstance(originalRequest);
          }
        } catch (refreshError) {
          console.error('‚ùå Auth: Token refresh failed:', refreshError);
          // Let the error fall through to trigger logout/redirect
        }
      }
    }

    if (shouldLogApiRequests) {
      console.error('‚ùå API Response Error:', error.response?.status, error.response?.data);
    }

    return Promise.reject(error);
  }
);

/**
 * Custom axios instance for API calls
 */
export const customInstance = <T>(config: AxiosRequestConfig): Promise<AxiosResponse<T>> => {
  return axiosInstance({
    ...config,
  });
};

// Type definitions for API models
export type AnswerCreate = import('./models').AnswerCreate;
export type AnswerRead = import('./models').AnswerRead;
export type AnswerUpdate = import('./models').AnswerUpdate;
export type EventCreate = import('./models').EventCreate;
export type EventRead = import('./models').EventRead;
export type EventUpdate = import('./models').EventUpdate;
export type EventParticipantCreate = import('./models').EventParticipantCreate;
export type EventParticipantRead = import('./models').EventParticipantRead;
export type EventParticipantUpdate = import('./models').EventParticipantUpdate;
export type InteractionCreate = import('./models').InteractionCreate;
export type InteractionRead = import('./models').InteractionRead;
export type InteractionUpdate = import('./models').InteractionUpdate;
export type QuestionCreate = import('./models').QuestionCreate;
export type QuestionRead = import('./models').QuestionRead;
export type QuestionUpdate = import('./models').QuestionUpdate;
export type UserCreate = import('./models').UserCreate;
export type UserRead = import('./models').UserRead;
export type UserUpdate = import('./models').UserUpdate;

/**
 * User Profile interface matching the API response structure
 * This represents the detailed user profile response from /api/v1/users/[user_id]
 */
export interface UserProfile {
  id: string;
  linkedin_url: string | null;
  auth_id: string;
  email: string;
  first_name: string;
  last_name: string;
  profile_picture: string | null;
  bio: string | null;
  title: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  last_active_at: string | null;
  connectDetails: string | null; //  connect details (not in API yet)
}

/**
 * Fetch a single user profile by ID from the API
 * @param userId - The unique identifier for the user
 * @returns Promise resolving to the user profile data
 */
export const fetchUserProfile = async (userId: string): Promise<UserProfile> => {
  if (!userId || userId.trim() === '') {
    throw new Error('User ID is required');
  }

  try {
    const response = await customInstance<UserProfile>({
      url: `/api/v1/users/${encodeURIComponent(userId)}`,
      method: 'GET',
    });

    return response.data;
  } catch (error: any) {
    // Enhanced error handling with specific error messages
    if (error?.response?.status === 404) {
      throw new Error('User profile not found');
    } else if (error?.response?.status === 403) {
      throw new Error('Access denied to user profile');
    } else if (error?.response?.status === 401) {
      throw new Error('Authentication required');
    } else if (error?.response?.status >= 500) {
      throw new Error('Server error occurred while fetching profile');
    } else if (!navigator.onLine) {
      throw new Error('No internet connection');
    } else {
      throw new Error(error?.message || 'Failed to fetch user profile');
    }
  }
};

/**
 * Interface for current user data from Logto
 */
export interface LogtoUserData {
  sub: string;
  jwt: string; // Optional JWT token
}

/**
 * @deprecated Use getCurrentUserProfile() instead - GET /api/v1/users/me now returns full user profile
 * Get current user ID from /api/v1/users/me
 * @param jwt - JWT token for authentication
 * @returns Promise resolving to the current user's ID
 */
export const getCurrentUserId = async (jwt: string): Promise<string> => {
  try {
    const response = await customInstance<{ user_id: string }>({
      url: `/api/v1/users/me`,
      method: 'GET',
      headers: {
        Authorization: `Bearer ${jwt}`,
      },
    });

    return response.data.user_id;
  } catch (error) {
    console.error('Failed to fetch current user ID:', error);
    throw error;
  }
};

/**
 * Get user profile by user ID
 * @param jwt - JWT token for authentication
 * @param userId - The user ID to fetch
 * @returns Promise resolving to the user profile
 */
export const getUserProfileById = async (jwt: string, userId: string): Promise<UserProfileApiResponse> => {
  try {
    const response = await customInstance<UserProfileApiResponse>({
      url: `/api/v1/users/${userId}`,
      method: 'GET',
      headers: {
        Authorization: `Bearer ${jwt}`,
      },
    });

    return response.data;
  } catch (error) {
    console.error('Failed to fetch user profile by ID:', error);
    throw error;
  }
};

/**
 * Get current user profile for authenticated user
 * @param jwt - JWT token for authentication
 * @returns Promise resolving to the user profile
 */
export const getCurrentUserProfile = async (jwt: string): Promise<UserProfileResponse> => {
  try {
    // GET /api/v1/users/me now returns the full user profile directly
    const response = await customInstance<UserProfileResponse>({
      url: `/api/v1/users/me`,
      method: 'GET',
      headers: {
        Authorization: `Bearer ${jwt}`,
      },
    });
    
    return response.data;
  } catch (error) {
    console.error('Failed to fetch current user profile:', error);
    throw error;
  }
};

/**
 * Get or create current user from Logto authentication data (for signup flow)
 * @param logtoData - User data from Logto authentication
 * @returns Promise resolving to the backend user profile
 */
export const signUpAndfetchCurrentUser = async (logtoData: any): Promise<UserProfileApiResponse> => {

  if (!logtoData.auth_id) {
    throw new Error('Logto sub (user ID) is required');
  }


  try {
    // Prepare request body with user data
    const requestBody = {
      step1: {
        fields_of_expertise: logtoData?.step1.fields_of_expertise,
        professional_background: logtoData?.step1.professional_background,
        can_help_with: logtoData?.step1.can_help_with,
      },
      step2: {
        interests: logtoData?.step2.interests,
      },
      step3: {
        full_name: logtoData?.step3.full_name,
        linkedin_url: logtoData?.step3.linkedin_url,
      },
      auth_id: logtoData?.auth_id,
      email: logtoData?.email,
    };


    const response = await customInstance<UserProfileApiResponse>({
      url: `/api/v1/users/me`,
      method: 'POST',
      data: requestBody,
      headers: {
        Authorization: `Bearer ${logtoData.jwt}`,
      },
    });

    return response.data;
  } catch (error: any) {
    // Enhanced error handling
    if (error?.response?.status === 400) {
      throw new Error('Invalid user data provided');
    } else if (error?.response?.status === 500) {
      throw new Error('Server error occurred while creating/fetching user');
    } else if (!navigator.onLine) {
      throw new Error('No internet connection');
    } else {
      throw new Error(error?.message || 'Failed to get current user');
    }
  }
};

/**
 * React Query hook for fetching user profile data
 * @param userId - The unique identifier for the user
 * @param options - Optional React Query configuration
 * @returns React Query result with user profile data, loading state, and error handling
 */
export const useUserProfile = (
  userId: string | undefined,
  options?: Omit<UseQueryOptions<UserProfile, Error>, 'queryKey' | 'queryFn'>
) => {
  return useQuery<UserProfile, Error>({
    queryKey: ['userProfile', userId],
    queryFn: () => {
      if (!userId) {
        throw new Error('User ID is required');
      }
      return fetchUserProfile(userId);
    },
    enabled: !!userId && userId.trim() !== '', // Only run query if userId is provided and not empty
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep in cache for 30 minutes
    retry: (failureCount, error: any) => {
      // Don't retry on 404 (user not found) or 403 (access denied)
      if (error?.message?.includes('not found') || error?.message?.includes('Access denied')) {
        return false;
      }
      // Retry up to 3 times for other errors
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
    ...options,
  });
};

// API function signatures
export const readEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: EventRead[] }>> => {
  return customInstance<{ data: EventRead[] }>({
    url: '/api/v1/events',
    method: 'GET',
    params,
    ...options,
  });
};

export const readEventApiV1EventsEventIdGet = (
  eventId: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventRead>> => {
  return customInstance<EventRead>({
    url: `/api/v1/events/${eventId}`,
    method: 'GET',
    ...options,
  });
};

export const createEventApiV1EventsPost = (
  data: EventCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventRead>> => {
  return customInstance<EventRead>({
    url: '/api/v1/events',
    method: 'POST',
    data,
    ...options,
  });
};

export const updateEventApiV1EventsEventIdPut = (
  eventId: string,
  data: EventUpdate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventRead>> => {
  return customInstance<EventRead>({
    url: `/api/v1/events/${eventId}`,
    method: 'PUT',
    data,
    ...options,
  });
};

export const readQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: QuestionRead[] }>> => {
  return customInstance<{ data: QuestionRead[] }>({
    url: '/api/v1/questions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createQuestionApiV1QuestionsPost = (
  data: QuestionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<QuestionRead>> => {
  return customInstance<QuestionRead>({
    url: '/api/v1/questions',
    method: 'POST',
    data,
    ...options,
  });
};


export const createInteractionApiV1InteractionsPost = (
  data: InteractionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<InteractionRead>> => {
  return customInstance<InteractionRead>({
    url: '/api/v1/interactions',
    method: 'POST',
    data,
    ...options,
  });
};

export const deleteInteractionApiV1InteractionsInteractionIdDelete = (
  interactionId: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/interactions/${interactionId}`,
    method: 'DELETE',
    ...options,
  });
};
export const getQuestionByID = (
  questionID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/questions/${questionID}`,
    method: 'GET',
    ...options,
  });
};

export const getMeTooInteractionByQuestionId = (
  questionID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/questions/${questionID}/me_too`,
    method: 'GET',
    ...options,
  });
};

export const getIcanHelpInteractionByQuestionId = (
  questionID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/questions/${questionID}/i_can_help`,
    method: 'GET',
    ...options,
  });
};

export const readInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: InteractionRead[] }>> => {
  return customInstance<{ data: InteractionRead[] }>({
    url: '/api/v1/interactions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createEventParticipantApiV1EventParticipantsPost = (
  data: EventParticipantCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventParticipantRead>> => {
  return customInstance<EventParticipantRead>({
    url: '/api/v1/event-participants',
    method: 'POST',
    data,
    ...options,
  });
};

export const readAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: AnswerRead[] }>> => {
  return customInstance<{ data: AnswerRead[] }>({
    url: '/api/v1/answers',
    method: 'GET',
    params,
    ...options,
  });
};

export const createAnswerApiV1AnswersPost = (
  data: AnswerCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnswerRead>> => {
  return customInstance<AnswerRead>({
    url: '/api/v1/answers',
    method: 'POST',
    data,
    ...options,
  });
};

export const readUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: UserRead[] }>> => {
  return customInstance<{ data: UserRead[] }>({
    url: '/api/v1/users',
    method: 'GET',
    params,
    ...options,
  });
};

export const createUserApiV1UsersPost = (
  data: UserCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UserRead>> => {
  return customInstance<UserRead>({
    url: '/api/v1/users',
    method: 'POST',
    data,
    ...options,
  });
};

// React Query hooks
export const useReadEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: EventRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['events', params],
    queryFn: () => readEventsApiV1EventsGet(params),
    ...options,
  });
};

export const useReadQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: QuestionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['questions', params],
    queryFn: () => readQuestionsApiV1QuestionsGet(params),
    ...options,
  });
};

export const useReadInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: InteractionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['interactions', params],
    queryFn: () => readInteractionsApiV1InteractionsGet(params),
    ...options,
  });
};

export const useCreateQuestionApiV1QuestionsPost = (
  options?: UseMutationOptions<AxiosResponse<QuestionRead>, Error, { data: QuestionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createQuestionApiV1QuestionsPost(data),
    ...options,
  });
};

export const useCreateInteractionApiV1InteractionsPost = (
  options?: UseMutationOptions<AxiosResponse<InteractionRead>, Error, { data: InteractionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createInteractionApiV1InteractionsPost(data),
    ...options,
  });
};

export const useDeleteInteractionApiV1InteractionsInteractionIdDelete = (
  options?: UseMutationOptions<AxiosResponse<void>, Error, { interactionId: string }>
) => {
  return useMutation({
    mutationFn: ({ interactionId }) => deleteInteractionApiV1InteractionsInteractionIdDelete(interactionId),
    ...options,
  });
};
export const useGetQuestionByID = (questionID: string | undefined,
) => {
  return useQuery({
    queryKey: ['question', questionID],
    queryFn: () => {
      if (!questionID) {
        throw new Error('Question ID is required');
      }
      return getQuestionByID(questionID);
    },
    // enabled: !!questionID,
  });
};
export const useGetMeTootInteractionByQuestionId = (
  questionID: string | undefined,
  options?: UseQueryOptions<AxiosResponse<void>, Error>
) => {
  return useQuery({
    queryKey: ['meTooInteraction', questionID],
    queryFn: () => {
      if (!questionID) {
        throw new Error('Question ID is required');
      }
      return getMeTooInteractionByQuestionId(questionID);
    },
    enabled: !!questionID,
    ...options,
  });
};
export const useGetIcanHelptInteractionByQuestionId = (
  questionID: string | undefined,
  options?: UseQueryOptions<AxiosResponse<void>, Error>
) => {
  return useQuery({
    queryKey: ['iCanHelpInteraction', questionID],
    queryFn: () => {
      if (!questionID) {
        throw new Error('Question ID is required');
      }
      return getIcanHelpInteractionByQuestionId(questionID);
    },
    enabled: !!questionID,
    ...options,
  });
};
export const useCreateEventParticipantApiV1EventParticipantsPost = (
  options?: UseMutationOptions<AxiosResponse<EventParticipantRead>, Error, { data: EventParticipantCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventParticipantApiV1EventParticipantsPost(data),
    ...options,
  });
};

export const useCreateEventApiV1EventsPost = (
  options?: UseMutationOptions<AxiosResponse<EventRead>, Error, { data: EventCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventApiV1EventsPost(data),
    ...options,
  });
};

export const useUpdateEventApiV1EventsEventIdPut = (
  options?: UseMutationOptions<AxiosResponse<EventRead>, Error, { eventId: string; data: EventUpdate }>
) => {
  return useMutation({
    mutationFn: ({ eventId, data }) => updateEventApiV1EventsEventIdPut(eventId, data),
    ...options,
  });
};

export const useCreateAnswerApiV1AnswersPost = (
  options?: UseMutationOptions<AxiosResponse<AnswerRead>, Error, { data: AnswerCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createAnswerApiV1AnswersPost(data),
    ...options,
  });
};

export const useCreateUserApiV1UsersPost = (
  options?: UseMutationOptions<AxiosResponse<UserRead>, Error, { data: UserCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createUserApiV1UsersPost(data),
    ...options,
  });
};

export const useReadAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: AnswerRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['answers', params],
    queryFn: () => readAnswersApiV1AnswersGet(params),
    ...options,
  });
};

export const useReadUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: UserRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => readUsersApiV1UsersGet(params),
    ...options,
  });
};

export const useReadEventApiV1EventsEventIdGet = (
  eventId: string,
  options?: UseQueryOptions<AxiosResponse<EventRead>, Error>
) => {
  return useQuery({
    queryKey: ['event', eventId],
    queryFn: () => readEventApiV1EventsEventIdGet(eventId),
    enabled: !!eventId,
    ...options,
  });
};