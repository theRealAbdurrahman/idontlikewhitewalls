/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Meetball API
 * API for Meetball - The Summeet's event networking platform
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

// Configure axios base URL for API requests
axios.defaults.baseURL = "http://localhost:8000";

import type {
  AnswerCreate,
  AnswerRead,
  AnswerUpdate,
  EventCreate,
  EventParticipantCreate,
  EventParticipantRead,
  EventParticipantUpdate,
  EventRead,
  EventUpdate,
  HTTPValidationError,
  InteractionCreate,
  InteractionRead,
  InteractionUpdate,
  QuestionCreate,
  QuestionRead,
  QuestionUpdate,
  ReadAnswersApiV1AnswersGetParams,
  ReadEventParticipantsApiV1EventParticipantsGetParams,
  ReadEventsApiV1EventsGetParams,
  ReadInteractionsApiV1InteractionsGetParams,
  ReadQuestionsApiV1QuestionsGetParams,
  ReadUsersApiV1UsersGetParams,
  UserCreate,
  UserRead,
  UserUpdate
} from './models';

/**
 * Retrieve users with pagination.
 * @summary Read Users
 */
export const readUsersApiV1UsersGet = (
    params?: ReadUsersApiV1UsersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead[]>> => {
    
    
    return axios.get(
      `/api/v1/users/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadUsersApiV1UsersGetQueryKey = (params?: ReadUsersApiV1UsersGetParams,) => {
    return [`/api/v1/users/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadUsersApiV1UsersGetQueryOptions = <TData = Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadUsersApiV1UsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUsersApiV1UsersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>> = ({ signal }) => readUsersApiV1UsersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUsersApiV1UsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>>
export type ReadUsersApiV1UsersGetQueryError = AxiosError<HTTPValidationError>


export function useReadUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadUsersApiV1UsersGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersApiV1UsersGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersApiV1UsersGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadUsersApiV1UsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersApiV1UsersGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersApiV1UsersGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadUsersApiV1UsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Users
 */

export function useReadUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadUsersApiV1UsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersApiV1UsersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUsersApiV1UsersGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new user.
 * @summary Create User
 */
export const createUserApiV1UsersPost = (
    userCreate: UserCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    
    return axios.post(
      `/api/v1/users/`,
      userCreate,options
    );
  }



export const getCreateUserApiV1UsersPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['createUserApiV1UsersPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  createUserApiV1UsersPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserApiV1UsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserApiV1UsersPost>>>
    export type CreateUserApiV1UsersPostMutationBody = UserCreate
    export type CreateUserApiV1UsersPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create User
 */
export const useCreateUserApiV1UsersPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUserApiV1UsersPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getCreateUserApiV1UsersPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get user by ID.
 * @summary Read User
 */
export const readUserApiV1UsersUserIdGet = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    
    return axios.get(
      `/api/v1/users/${userId}`,options
    );
  }


export const getReadUserApiV1UsersUserIdGetQueryKey = (userId: string,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getReadUserApiV1UsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUserApiV1UsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>> = ({ signal }) => readUserApiV1UsersUserIdGet(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUserApiV1UsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>>
export type ReadUserApiV1UsersUserIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read User
 */

export function useReadUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError = AxiosError<HTTPValidationError>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserApiV1UsersUserIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUserApiV1UsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a user.
 * @summary Update User
 */
export const updateUserApiV1UsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    
    return axios.put(
      `/api/v1/users/${userId}`,
      userUpdate,options
    );
  }



export const getUpdateUserApiV1UsersUserIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext> => {

const mutationKey = ['updateUserApiV1UsersUserIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>, {userId: string;data: UserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserApiV1UsersUserIdPut(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserApiV1UsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>>
    export type UpdateUserApiV1UsersUserIdPutMutationBody = UserUpdate
    export type UpdateUserApiV1UsersUserIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update User
 */
export const useUpdateUserApiV1UsersUserIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserApiV1UsersUserIdPut>>,
        TError,
        {userId: string;data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserApiV1UsersUserIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a user.
 * @summary Delete User
 */
export const deleteUserApiV1UsersUserIdDelete = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    
    
    return axios.delete(
      `/api/v1/users/${userId}`,options
    );
  }



export const getDeleteUserApiV1UsersUserIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUserApiV1UsersUserIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUserApiV1UsersUserIdDelete(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserApiV1UsersUserIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>>
    
    export type DeleteUserApiV1UsersUserIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete User
 */
export const useDeleteUserApiV1UsersUserIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserApiV1UsersUserIdDelete>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserApiV1UsersUserIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve events with pagination.
 * @summary Read Events
 */
export const readEventsApiV1EventsGet = (
    params?: ReadEventsApiV1EventsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead[]>> => {
    
    
    return axios.get(
      `/api/v1/events/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadEventsApiV1EventsGetQueryKey = (params?: ReadEventsApiV1EventsGetParams,) => {
    return [`/api/v1/events/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadEventsApiV1EventsGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadEventsApiV1EventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventsApiV1EventsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>> = ({ signal }) => readEventsApiV1EventsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventsApiV1EventsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>>
export type ReadEventsApiV1EventsGetQueryError = AxiosError<HTTPValidationError>


export function useReadEventsApiV1EventsGet<TData = Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadEventsApiV1EventsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsApiV1EventsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsApiV1EventsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsApiV1EventsGet<TData = Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventsApiV1EventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsApiV1EventsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsApiV1EventsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsApiV1EventsGet<TData = Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventsApiV1EventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Events
 */

export function useReadEventsApiV1EventsGet<TData = Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventsApiV1EventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiV1EventsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventsApiV1EventsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new event.
 * @summary Create Event
 */
export const createEventApiV1EventsPost = (
    eventCreate: EventCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.post(
      `/api/v1/events/`,
      eventCreate,options
    );
  }



export const getCreateEventApiV1EventsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventApiV1EventsPost>>, TError,{data: EventCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createEventApiV1EventsPost>>, TError,{data: EventCreate}, TContext> => {

const mutationKey = ['createEventApiV1EventsPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEventApiV1EventsPost>>, {data: EventCreate}> = (props) => {
          const {data} = props ?? {};

          return  createEventApiV1EventsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEventApiV1EventsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createEventApiV1EventsPost>>>
    export type CreateEventApiV1EventsPostMutationBody = EventCreate
    export type CreateEventApiV1EventsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Event
 */
export const useCreateEventApiV1EventsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventApiV1EventsPost>>, TError,{data: EventCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEventApiV1EventsPost>>,
        TError,
        {data: EventCreate},
        TContext
      > => {

      const mutationOptions = getCreateEventApiV1EventsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get event by ID.
 * @summary Read Event
 */
export const readEventApiV1EventsEventIdGet = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.get(
      `/api/v1/events/${eventId}`,options
    );
  }


export const getReadEventApiV1EventsEventIdGetQueryKey = (eventId: string,) => {
    return [`/api/v1/events/${eventId}`] as const;
    }

    
export const getReadEventApiV1EventsEventIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError = AxiosError<HTTPValidationError>>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventApiV1EventsEventIdGetQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>> = ({ signal }) => readEventApiV1EventsEventIdGet(eventId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventApiV1EventsEventIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>>
export type ReadEventApiV1EventsEventIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadEventApiV1EventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError = AxiosError<HTTPValidationError>>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventApiV1EventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError = AxiosError<HTTPValidationError>>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventApiV1EventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError = AxiosError<HTTPValidationError>>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Event
 */

export function useReadEventApiV1EventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError = AxiosError<HTTPValidationError>>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiV1EventsEventIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventApiV1EventsEventIdGetQueryOptions(eventId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an event.
 * @summary Update Event
 */
export const updateEventApiV1EventsEventIdPut = (
    eventId: string,
    eventUpdate: EventUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.put(
      `/api/v1/events/${eventId}`,
      eventUpdate,options
    );
  }



export const getUpdateEventApiV1EventsEventIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>, TError,{eventId: string;data: EventUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>, TError,{eventId: string;data: EventUpdate}, TContext> => {

const mutationKey = ['updateEventApiV1EventsEventIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>, {eventId: string;data: EventUpdate}> = (props) => {
          const {eventId,data} = props ?? {};

          return  updateEventApiV1EventsEventIdPut(eventId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEventApiV1EventsEventIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>>
    export type UpdateEventApiV1EventsEventIdPutMutationBody = EventUpdate
    export type UpdateEventApiV1EventsEventIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Event
 */
export const useUpdateEventApiV1EventsEventIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>, TError,{eventId: string;data: EventUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEventApiV1EventsEventIdPut>>,
        TError,
        {eventId: string;data: EventUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateEventApiV1EventsEventIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an event.
 * @summary Delete Event
 */
export const deleteEventApiV1EventsEventIdDelete = (
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.delete(
      `/api/v1/events/${eventId}`,options
    );
  }



export const getDeleteEventApiV1EventsEventIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>, TError,{eventId: string}, TContext> => {

const mutationKey = ['deleteEventApiV1EventsEventIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  deleteEventApiV1EventsEventIdDelete(eventId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEventApiV1EventsEventIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>>
    
    export type DeleteEventApiV1EventsEventIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Event
 */
export const useDeleteEventApiV1EventsEventIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>, TError,{eventId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEventApiV1EventsEventIdDelete>>,
        TError,
        {eventId: string},
        TContext
      > => {

      const mutationOptions = getDeleteEventApiV1EventsEventIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve event participants with pagination.
 * @summary Read Event Participants
 */
export const readEventParticipantsApiV1EventParticipantsGet = (
    params?: ReadEventParticipantsApiV1EventParticipantsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventParticipantRead[]>> => {
    
    
    return axios.get(
      `/api/v1/event-participants/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadEventParticipantsApiV1EventParticipantsGetQueryKey = (params?: ReadEventParticipantsApiV1EventParticipantsGetParams,) => {
    return [`/api/v1/event-participants/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadEventParticipantsApiV1EventParticipantsGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadEventParticipantsApiV1EventParticipantsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventParticipantsApiV1EventParticipantsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>> = ({ signal }) => readEventParticipantsApiV1EventParticipantsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventParticipantsApiV1EventParticipantsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>>
export type ReadEventParticipantsApiV1EventParticipantsGetQueryError = AxiosError<HTTPValidationError>


export function useReadEventParticipantsApiV1EventParticipantsGet<TData = Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadEventParticipantsApiV1EventParticipantsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventParticipantsApiV1EventParticipantsGet<TData = Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventParticipantsApiV1EventParticipantsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventParticipantsApiV1EventParticipantsGet<TData = Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventParticipantsApiV1EventParticipantsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Event Participants
 */

export function useReadEventParticipantsApiV1EventParticipantsGet<TData = Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadEventParticipantsApiV1EventParticipantsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantsApiV1EventParticipantsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventParticipantsApiV1EventParticipantsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new event participant.
 * @summary Create Event Participant
 */
export const createEventParticipantApiV1EventParticipantsPost = (
    eventParticipantCreate: EventParticipantCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventParticipantRead>> => {
    
    
    return axios.post(
      `/api/v1/event-participants/`,
      eventParticipantCreate,options
    );
  }



export const getCreateEventParticipantApiV1EventParticipantsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>, TError,{data: EventParticipantCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>, TError,{data: EventParticipantCreate}, TContext> => {

const mutationKey = ['createEventParticipantApiV1EventParticipantsPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>, {data: EventParticipantCreate}> = (props) => {
          const {data} = props ?? {};

          return  createEventParticipantApiV1EventParticipantsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEventParticipantApiV1EventParticipantsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>>
    export type CreateEventParticipantApiV1EventParticipantsPostMutationBody = EventParticipantCreate
    export type CreateEventParticipantApiV1EventParticipantsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Event Participant
 */
export const useCreateEventParticipantApiV1EventParticipantsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>, TError,{data: EventParticipantCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEventParticipantApiV1EventParticipantsPost>>,
        TError,
        {data: EventParticipantCreate},
        TContext
      > => {

      const mutationOptions = getCreateEventParticipantApiV1EventParticipantsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get event participant by ID.
 * @summary Read Event Participant
 */
export const readEventParticipantApiV1EventParticipantsParticipantIdGet = (
    participantId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventParticipantRead>> => {
    
    
    return axios.get(
      `/api/v1/event-participants/${participantId}`,options
    );
  }


export const getReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryKey = (participantId: string,) => {
    return [`/api/v1/event-participants/${participantId}`] as const;
    }

    
export const getReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError = AxiosError<HTTPValidationError>>(participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryKey(participantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>> = ({ signal }) => readEventParticipantApiV1EventParticipantsParticipantIdGet(participantId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(participantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>>
export type ReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadEventParticipantApiV1EventParticipantsParticipantIdGet<TData = Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError = AxiosError<HTTPValidationError>>(
 participantId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventParticipantApiV1EventParticipantsParticipantIdGet<TData = Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError = AxiosError<HTTPValidationError>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventParticipantApiV1EventParticipantsParticipantIdGet<TData = Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError = AxiosError<HTTPValidationError>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Event Participant
 */

export function useReadEventParticipantApiV1EventParticipantsParticipantIdGet<TData = Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError = AxiosError<HTTPValidationError>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventParticipantApiV1EventParticipantsParticipantIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventParticipantApiV1EventParticipantsParticipantIdGetQueryOptions(participantId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an event participant.
 * @summary Update Event Participant
 */
export const updateEventParticipantApiV1EventParticipantsParticipantIdPut = (
    participantId: string,
    eventParticipantUpdate: EventParticipantUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventParticipantRead>> => {
    
    
    return axios.put(
      `/api/v1/event-participants/${participantId}`,
      eventParticipantUpdate,options
    );
  }



export const getUpdateEventParticipantApiV1EventParticipantsParticipantIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>, TError,{participantId: string;data: EventParticipantUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>, TError,{participantId: string;data: EventParticipantUpdate}, TContext> => {

const mutationKey = ['updateEventParticipantApiV1EventParticipantsParticipantIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>, {participantId: string;data: EventParticipantUpdate}> = (props) => {
          const {participantId,data} = props ?? {};

          return  updateEventParticipantApiV1EventParticipantsParticipantIdPut(participantId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEventParticipantApiV1EventParticipantsParticipantIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>>
    export type UpdateEventParticipantApiV1EventParticipantsParticipantIdPutMutationBody = EventParticipantUpdate
    export type UpdateEventParticipantApiV1EventParticipantsParticipantIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Event Participant
 */
export const useUpdateEventParticipantApiV1EventParticipantsParticipantIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>, TError,{participantId: string;data: EventParticipantUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEventParticipantApiV1EventParticipantsParticipantIdPut>>,
        TError,
        {participantId: string;data: EventParticipantUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateEventParticipantApiV1EventParticipantsParticipantIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an event participant.
 * @summary Delete Event Participant
 */
export const deleteEventParticipantApiV1EventParticipantsParticipantIdDelete = (
    participantId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventParticipantRead>> => {
    
    
    return axios.delete(
      `/api/v1/event-participants/${participantId}`,options
    );
  }



export const getDeleteEventParticipantApiV1EventParticipantsParticipantIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext> => {

const mutationKey = ['deleteEventParticipantApiV1EventParticipantsParticipantIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>, {participantId: string}> = (props) => {
          const {participantId} = props ?? {};

          return  deleteEventParticipantApiV1EventParticipantsParticipantIdDelete(participantId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEventParticipantApiV1EventParticipantsParticipantIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>>
    
    export type DeleteEventParticipantApiV1EventParticipantsParticipantIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Event Participant
 */
export const useDeleteEventParticipantApiV1EventParticipantsParticipantIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEventParticipantApiV1EventParticipantsParticipantIdDelete>>,
        TError,
        {participantId: string},
        TContext
      > => {

      const mutationOptions = getDeleteEventParticipantApiV1EventParticipantsParticipantIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve questions with pagination.
 * @summary Read Questions
 */
export const readQuestionsApiV1QuestionsGet = (
    params?: ReadQuestionsApiV1QuestionsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionRead[]>> => {
    
    
    return axios.get(
      `/api/v1/questions/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadQuestionsApiV1QuestionsGetQueryKey = (params?: ReadQuestionsApiV1QuestionsGetParams,) => {
    return [`/api/v1/questions/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadQuestionsApiV1QuestionsGetQueryOptions = <TData = Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadQuestionsApiV1QuestionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadQuestionsApiV1QuestionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>> = ({ signal }) => readQuestionsApiV1QuestionsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadQuestionsApiV1QuestionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>>
export type ReadQuestionsApiV1QuestionsGetQueryError = AxiosError<HTTPValidationError>


export function useReadQuestionsApiV1QuestionsGet<TData = Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadQuestionsApiV1QuestionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>,
          TError,
          Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadQuestionsApiV1QuestionsGet<TData = Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadQuestionsApiV1QuestionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>,
          TError,
          Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadQuestionsApiV1QuestionsGet<TData = Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadQuestionsApiV1QuestionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Questions
 */

export function useReadQuestionsApiV1QuestionsGet<TData = Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadQuestionsApiV1QuestionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionsApiV1QuestionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadQuestionsApiV1QuestionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new question.
 * @summary Create Question
 */
export const createQuestionApiV1QuestionsPost = (
    questionCreate: QuestionCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionRead>> => {
    
    
    return axios.post(
      `/api/v1/questions/`,
      questionCreate,options
    );
  }



export const getCreateQuestionApiV1QuestionsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>, TError,{data: QuestionCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>, TError,{data: QuestionCreate}, TContext> => {

const mutationKey = ['createQuestionApiV1QuestionsPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>, {data: QuestionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createQuestionApiV1QuestionsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateQuestionApiV1QuestionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>>
    export type CreateQuestionApiV1QuestionsPostMutationBody = QuestionCreate
    export type CreateQuestionApiV1QuestionsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Question
 */
export const useCreateQuestionApiV1QuestionsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>, TError,{data: QuestionCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createQuestionApiV1QuestionsPost>>,
        TError,
        {data: QuestionCreate},
        TContext
      > => {

      const mutationOptions = getCreateQuestionApiV1QuestionsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get question by ID.
 * @summary Read Question
 */
export const readQuestionApiV1QuestionsQuestionIdGet = (
    questionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionRead>> => {
    
    
    return axios.get(
      `/api/v1/questions/${questionId}`,options
    );
  }


export const getReadQuestionApiV1QuestionsQuestionIdGetQueryKey = (questionId: string,) => {
    return [`/api/v1/questions/${questionId}`] as const;
    }

    
export const getReadQuestionApiV1QuestionsQuestionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError = AxiosError<HTTPValidationError>>(questionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadQuestionApiV1QuestionsQuestionIdGetQueryKey(questionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>> = ({ signal }) => readQuestionApiV1QuestionsQuestionIdGet(questionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(questionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadQuestionApiV1QuestionsQuestionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>>
export type ReadQuestionApiV1QuestionsQuestionIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadQuestionApiV1QuestionsQuestionIdGet<TData = Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 questionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>,
          TError,
          Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadQuestionApiV1QuestionsQuestionIdGet<TData = Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 questionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>,
          TError,
          Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadQuestionApiV1QuestionsQuestionIdGet<TData = Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 questionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Question
 */

export function useReadQuestionApiV1QuestionsQuestionIdGet<TData = Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 questionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readQuestionApiV1QuestionsQuestionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadQuestionApiV1QuestionsQuestionIdGetQueryOptions(questionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a question.
 * @summary Update Question
 */
export const updateQuestionApiV1QuestionsQuestionIdPut = (
    questionId: string,
    questionUpdate: QuestionUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionRead>> => {
    
    
    return axios.put(
      `/api/v1/questions/${questionId}`,
      questionUpdate,options
    );
  }



export const getUpdateQuestionApiV1QuestionsQuestionIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>, TError,{questionId: string;data: QuestionUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>, TError,{questionId: string;data: QuestionUpdate}, TContext> => {

const mutationKey = ['updateQuestionApiV1QuestionsQuestionIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>, {questionId: string;data: QuestionUpdate}> = (props) => {
          const {questionId,data} = props ?? {};

          return  updateQuestionApiV1QuestionsQuestionIdPut(questionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuestionApiV1QuestionsQuestionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>>
    export type UpdateQuestionApiV1QuestionsQuestionIdPutMutationBody = QuestionUpdate
    export type UpdateQuestionApiV1QuestionsQuestionIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Question
 */
export const useUpdateQuestionApiV1QuestionsQuestionIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>, TError,{questionId: string;data: QuestionUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateQuestionApiV1QuestionsQuestionIdPut>>,
        TError,
        {questionId: string;data: QuestionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateQuestionApiV1QuestionsQuestionIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a question.
 * @summary Delete Question
 */
export const deleteQuestionApiV1QuestionsQuestionIdDelete = (
    questionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionRead>> => {
    
    
    return axios.delete(
      `/api/v1/questions/${questionId}`,options
    );
  }



export const getDeleteQuestionApiV1QuestionsQuestionIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>, TError,{questionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>, TError,{questionId: string}, TContext> => {

const mutationKey = ['deleteQuestionApiV1QuestionsQuestionIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>, {questionId: string}> = (props) => {
          const {questionId} = props ?? {};

          return  deleteQuestionApiV1QuestionsQuestionIdDelete(questionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteQuestionApiV1QuestionsQuestionIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>>
    
    export type DeleteQuestionApiV1QuestionsQuestionIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Question
 */
export const useDeleteQuestionApiV1QuestionsQuestionIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>, TError,{questionId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteQuestionApiV1QuestionsQuestionIdDelete>>,
        TError,
        {questionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteQuestionApiV1QuestionsQuestionIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve answers with pagination.
 * @summary Read Answers
 */
export const readAnswersApiV1AnswersGet = (
    params?: ReadAnswersApiV1AnswersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerRead[]>> => {
    
    
    return axios.get(
      `/api/v1/answers/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadAnswersApiV1AnswersGetQueryKey = (params?: ReadAnswersApiV1AnswersGetParams,) => {
    return [`/api/v1/answers/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadAnswersApiV1AnswersGetQueryOptions = <TData = Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadAnswersApiV1AnswersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadAnswersApiV1AnswersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>> = ({ signal }) => readAnswersApiV1AnswersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadAnswersApiV1AnswersGetQueryResult = NonNullable<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>>
export type ReadAnswersApiV1AnswersGetQueryError = AxiosError<HTTPValidationError>


export function useReadAnswersApiV1AnswersGet<TData = Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadAnswersApiV1AnswersGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>,
          TError,
          Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnswersApiV1AnswersGet<TData = Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadAnswersApiV1AnswersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>,
          TError,
          Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnswersApiV1AnswersGet<TData = Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadAnswersApiV1AnswersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Answers
 */

export function useReadAnswersApiV1AnswersGet<TData = Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadAnswersApiV1AnswersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswersApiV1AnswersGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadAnswersApiV1AnswersGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new answer.
 * @summary Create Answer
 */
export const createAnswerApiV1AnswersPost = (
    answerCreate: AnswerCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerRead>> => {
    
    
    return axios.post(
      `/api/v1/answers/`,
      answerCreate,options
    );
  }



export const getCreateAnswerApiV1AnswersPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>, TError,{data: AnswerCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>, TError,{data: AnswerCreate}, TContext> => {

const mutationKey = ['createAnswerApiV1AnswersPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>, {data: AnswerCreate}> = (props) => {
          const {data} = props ?? {};

          return  createAnswerApiV1AnswersPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAnswerApiV1AnswersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>>
    export type CreateAnswerApiV1AnswersPostMutationBody = AnswerCreate
    export type CreateAnswerApiV1AnswersPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Answer
 */
export const useCreateAnswerApiV1AnswersPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>, TError,{data: AnswerCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAnswerApiV1AnswersPost>>,
        TError,
        {data: AnswerCreate},
        TContext
      > => {

      const mutationOptions = getCreateAnswerApiV1AnswersPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get answer by ID.
 * @summary Read Answer
 */
export const readAnswerApiV1AnswersAnswerIdGet = (
    answerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerRead>> => {
    
    
    return axios.get(
      `/api/v1/answers/${answerId}`,options
    );
  }


export const getReadAnswerApiV1AnswersAnswerIdGetQueryKey = (answerId: string,) => {
    return [`/api/v1/answers/${answerId}`] as const;
    }

    
export const getReadAnswerApiV1AnswersAnswerIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError = AxiosError<HTTPValidationError>>(answerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadAnswerApiV1AnswersAnswerIdGetQueryKey(answerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>> = ({ signal }) => readAnswerApiV1AnswersAnswerIdGet(answerId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(answerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadAnswerApiV1AnswersAnswerIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>>
export type ReadAnswerApiV1AnswersAnswerIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadAnswerApiV1AnswersAnswerIdGet<TData = Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError = AxiosError<HTTPValidationError>>(
 answerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>,
          TError,
          Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnswerApiV1AnswersAnswerIdGet<TData = Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError = AxiosError<HTTPValidationError>>(
 answerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>,
          TError,
          Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnswerApiV1AnswersAnswerIdGet<TData = Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError = AxiosError<HTTPValidationError>>(
 answerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Answer
 */

export function useReadAnswerApiV1AnswersAnswerIdGet<TData = Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError = AxiosError<HTTPValidationError>>(
 answerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnswerApiV1AnswersAnswerIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadAnswerApiV1AnswersAnswerIdGetQueryOptions(answerId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an answer.
 * @summary Update Answer
 */
export const updateAnswerApiV1AnswersAnswerIdPut = (
    answerId: string,
    answerUpdate: AnswerUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerRead>> => {
    
    
    return axios.put(
      `/api/v1/answers/${answerId}`,
      answerUpdate,options
    );
  }



export const getUpdateAnswerApiV1AnswersAnswerIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>, TError,{answerId: string;data: AnswerUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>, TError,{answerId: string;data: AnswerUpdate}, TContext> => {

const mutationKey = ['updateAnswerApiV1AnswersAnswerIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>, {answerId: string;data: AnswerUpdate}> = (props) => {
          const {answerId,data} = props ?? {};

          return  updateAnswerApiV1AnswersAnswerIdPut(answerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAnswerApiV1AnswersAnswerIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>>
    export type UpdateAnswerApiV1AnswersAnswerIdPutMutationBody = AnswerUpdate
    export type UpdateAnswerApiV1AnswersAnswerIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Answer
 */
export const useUpdateAnswerApiV1AnswersAnswerIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>, TError,{answerId: string;data: AnswerUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAnswerApiV1AnswersAnswerIdPut>>,
        TError,
        {answerId: string;data: AnswerUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateAnswerApiV1AnswersAnswerIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an answer.
 * @summary Delete Answer
 */
export const deleteAnswerApiV1AnswersAnswerIdDelete = (
    answerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerRead>> => {
    
    
    return axios.delete(
      `/api/v1/answers/${answerId}`,options
    );
  }



export const getDeleteAnswerApiV1AnswersAnswerIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>, TError,{answerId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>, TError,{answerId: string}, TContext> => {

const mutationKey = ['deleteAnswerApiV1AnswersAnswerIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>, {answerId: string}> = (props) => {
          const {answerId} = props ?? {};

          return  deleteAnswerApiV1AnswersAnswerIdDelete(answerId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAnswerApiV1AnswersAnswerIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>>
    
    export type DeleteAnswerApiV1AnswersAnswerIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Answer
 */
export const useDeleteAnswerApiV1AnswersAnswerIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>, TError,{answerId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAnswerApiV1AnswersAnswerIdDelete>>,
        TError,
        {answerId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAnswerApiV1AnswersAnswerIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve interactions with pagination.
 * @summary Read Interactions
 */
export const readInteractionsApiV1InteractionsGet = (
    params?: ReadInteractionsApiV1InteractionsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InteractionRead[]>> => {
    
    
    return axios.get(
      `/api/v1/interactions/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadInteractionsApiV1InteractionsGetQueryKey = (params?: ReadInteractionsApiV1InteractionsGetParams,) => {
    return [`/api/v1/interactions/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadInteractionsApiV1InteractionsGetQueryOptions = <TData = Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError = AxiosError<HTTPValidationError>>(params?: ReadInteractionsApiV1InteractionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadInteractionsApiV1InteractionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>> = ({ signal }) => readInteractionsApiV1InteractionsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadInteractionsApiV1InteractionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>>
export type ReadInteractionsApiV1InteractionsGetQueryError = AxiosError<HTTPValidationError>


export function useReadInteractionsApiV1InteractionsGet<TData = Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params: undefined |  ReadInteractionsApiV1InteractionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>,
          TError,
          Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadInteractionsApiV1InteractionsGet<TData = Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadInteractionsApiV1InteractionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>,
          TError,
          Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadInteractionsApiV1InteractionsGet<TData = Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadInteractionsApiV1InteractionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Interactions
 */

export function useReadInteractionsApiV1InteractionsGet<TData = Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadInteractionsApiV1InteractionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionsApiV1InteractionsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadInteractionsApiV1InteractionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new interaction.
 * @summary Create Interaction
 */
export const createInteractionApiV1InteractionsPost = (
    interactionCreate: InteractionCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InteractionRead>> => {
    
    
    return axios.post(
      `/api/v1/interactions/`,
      interactionCreate,options
    );
  }



export const getCreateInteractionApiV1InteractionsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>, TError,{data: InteractionCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>, TError,{data: InteractionCreate}, TContext> => {

const mutationKey = ['createInteractionApiV1InteractionsPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>, {data: InteractionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createInteractionApiV1InteractionsPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateInteractionApiV1InteractionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>>
    export type CreateInteractionApiV1InteractionsPostMutationBody = InteractionCreate
    export type CreateInteractionApiV1InteractionsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Interaction
 */
export const useCreateInteractionApiV1InteractionsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>, TError,{data: InteractionCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createInteractionApiV1InteractionsPost>>,
        TError,
        {data: InteractionCreate},
        TContext
      > => {

      const mutationOptions = getCreateInteractionApiV1InteractionsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get interaction by ID.
 * @summary Read Interaction
 */
export const readInteractionApiV1InteractionsInteractionIdGet = (
    interactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InteractionRead>> => {
    
    
    return axios.get(
      `/api/v1/interactions/${interactionId}`,options
    );
  }


export const getReadInteractionApiV1InteractionsInteractionIdGetQueryKey = (interactionId: string,) => {
    return [`/api/v1/interactions/${interactionId}`] as const;
    }

    
export const getReadInteractionApiV1InteractionsInteractionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError = AxiosError<HTTPValidationError>>(interactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadInteractionApiV1InteractionsInteractionIdGetQueryKey(interactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>> = ({ signal }) => readInteractionApiV1InteractionsInteractionIdGet(interactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(interactionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadInteractionApiV1InteractionsInteractionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>>
export type ReadInteractionApiV1InteractionsInteractionIdGetQueryError = AxiosError<HTTPValidationError>


export function useReadInteractionApiV1InteractionsInteractionIdGet<TData = Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 interactionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>,
          TError,
          Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadInteractionApiV1InteractionsInteractionIdGet<TData = Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 interactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>,
          TError,
          Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadInteractionApiV1InteractionsInteractionIdGet<TData = Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 interactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Interaction
 */

export function useReadInteractionApiV1InteractionsInteractionIdGet<TData = Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError = AxiosError<HTTPValidationError>>(
 interactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readInteractionApiV1InteractionsInteractionIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadInteractionApiV1InteractionsInteractionIdGetQueryOptions(interactionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an interaction.
 * @summary Update Interaction
 */
export const updateInteractionApiV1InteractionsInteractionIdPut = (
    interactionId: string,
    interactionUpdate: InteractionUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InteractionRead>> => {
    
    
    return axios.put(
      `/api/v1/interactions/${interactionId}`,
      interactionUpdate,options
    );
  }



export const getUpdateInteractionApiV1InteractionsInteractionIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>, TError,{interactionId: string;data: InteractionUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>, TError,{interactionId: string;data: InteractionUpdate}, TContext> => {

const mutationKey = ['updateInteractionApiV1InteractionsInteractionIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>, {interactionId: string;data: InteractionUpdate}> = (props) => {
          const {interactionId,data} = props ?? {};

          return  updateInteractionApiV1InteractionsInteractionIdPut(interactionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateInteractionApiV1InteractionsInteractionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>>
    export type UpdateInteractionApiV1InteractionsInteractionIdPutMutationBody = InteractionUpdate
    export type UpdateInteractionApiV1InteractionsInteractionIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Interaction
 */
export const useUpdateInteractionApiV1InteractionsInteractionIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>, TError,{interactionId: string;data: InteractionUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateInteractionApiV1InteractionsInteractionIdPut>>,
        TError,
        {interactionId: string;data: InteractionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateInteractionApiV1InteractionsInteractionIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an interaction.
 * @summary Delete Interaction
 */
export const deleteInteractionApiV1InteractionsInteractionIdDelete = (
    interactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InteractionRead>> => {
    
    
    return axios.delete(
      `/api/v1/interactions/${interactionId}`,options
    );
  }



export const getDeleteInteractionApiV1InteractionsInteractionIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>, TError,{interactionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>, TError,{interactionId: string}, TContext> => {

const mutationKey = ['deleteInteractionApiV1InteractionsInteractionIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>, {interactionId: string}> = (props) => {
          const {interactionId} = props ?? {};

          return  deleteInteractionApiV1InteractionsInteractionIdDelete(interactionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteInteractionApiV1InteractionsInteractionIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>>
    
    export type DeleteInteractionApiV1InteractionsInteractionIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Interaction
 */
export const useDeleteInteractionApiV1InteractionsInteractionIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>, TError,{interactionId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteInteractionApiV1InteractionsInteractionIdDelete>>,
        TError,
        {interactionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteInteractionApiV1InteractionsInteractionIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Root endpoint to check if API is running.
 * @summary Root
 */
export const rootGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/`,options
    );
  }


export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = AxiosError<unknown>


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Health check endpoint.
 * @summary Health Check
 */
export const healthCheckHealthGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/health`,options
    );
  }


export const getHealthCheckHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = AxiosError<unknown>


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
