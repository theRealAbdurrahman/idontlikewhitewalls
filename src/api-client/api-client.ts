/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Meetball API
 * API for Meetball - The Summeet's event networking platform
 * OpenAPI spec version: 0.1.0
 */
import Axios, { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useMutation, useQuery, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { apiConfig, shouldLogApiRequests } from '../config/api';

/**
 * Enhanced error handling for API requests
 */
const handleApiError = (error: AxiosError): AxiosError => {
  if (error.response) {
    // Server responded with error status
    console.error('‚ùå API HTTP Error:', {
      status: error.response.status,
      statusText: error.response.statusText,
      data: error.response.data,
      url: error.config?.url,
    });
  } else if (error.request) {
    // Network error - request was made but no response received
    console.error('‚ùå API Network Error:', {
      message: 'Backend server is unreachable',
      baseURL: error.config?.baseURL,
      url: error.config?.url,
      timeout: error.config?.timeout,
      details: 'Please check if the backend service is running and accessible',
    });
    
    // Add user-friendly error message
    error.message = `Network Error: Unable to reach the backend server at ${error.config?.baseURL}. Please check your internet connection or try again later.`;
  } else {
    // Request setup error
    console.error('‚ùå API Setup Error:', {
      message: error.message,
      url: error.config?.url,
    });
  }
  
  return error;
};

/**
 * Configure axios instance with base URL and interceptors
 */
const axiosInstance = Axios.create({
  baseURL: apiConfig.baseURL,
  timeout: apiConfig.timeout,
  headers: apiConfig.headers,
});

// Request interceptor for debugging in development
if (shouldLogApiRequests) {
  axiosInstance.interceptors.request.use(
    (config) => {
      console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`, {
        data: config.data,
        params: config.params,
        baseURL: config.baseURL,
      });
      return config;
    },
    (error) => {
      console.error('‚ùå API Request Error:', error);
      return Promise.reject(error);
    }
  );

  // Enhanced response interceptor for debugging in development
  axiosInstance.interceptors.response.use(
    (response) => {
      console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`, response.data);
      return response;
    },
    (error: AxiosError) => {
      const enhancedError = handleApiError(error);
      return Promise.reject(enhancedError);
    }
  );
} else {
  // Production error handling (no debug logs)
  axiosInstance.interceptors.response.use(
    (response) => response,
    (error: AxiosError) => {
      const enhancedError = handleApiError(error);
      return Promise.reject(enhancedError);
    }
  );
}

/**
 * Custom axios instance for API calls with enhanced error handling
 */
export const customInstance = <T>(config: AxiosRequestConfig): Promise<AxiosResponse<T>> => {
  return axiosInstance({
    ...config,
  }).catch((error: AxiosError) => {
    // Additional error context for debugging
    if (shouldLogApiRequests) {
      console.error('‚ùå API Call Failed:', {
        url: config.url,
        method: config.method,
        baseURL: axiosInstance.defaults.baseURL,
        isNetworkError: !error.response,
        errorCode: error.code,
      });
    }
    
    throw error;
  });
};

// Type definitions for API models
export type AnswerCreate = import('./models').AnswerCreate;
export type AnswerRead = import('./models').AnswerRead;
export type AnswerUpdate = import('./models').AnswerUpdate;
export type EventCreate = import('./models').EventCreate;
export type EventRead = import('./models').EventRead;
export type EventUpdate = import('./models').EventUpdate;
export type EventParticipantCreate = import('./models').EventParticipantCreate;
export type EventParticipantRead = import('./models').EventParticipantRead;
export type EventParticipantUpdate = import('./models').EventParticipantUpdate;
export type InteractionCreate = import('./models').InteractionCreate;
export type InteractionRead = import('./models').InteractionRead;
export type InteractionUpdate = import('./models').InteractionUpdate;
export type QuestionCreate = import('./models').QuestionCreate;
export type QuestionRead = import('./models').QuestionRead;
export type QuestionUpdate = import('./models').QuestionUpdate;
export type UserCreate = import('./models').UserCreate;
export type UserRead = import('./models').UserRead;
export type UserUpdate = import('./models').UserUpdate;

// API function signatures
export const readEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: EventRead[] }>> => {
  return customInstance<{ data: EventRead[] }>({
    url: '/api/v1/events',
    method: 'GET',
    params,
    ...options,
  });
};

export const createEventApiV1EventsPost = (
  data: EventCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventRead>> => {
  return customInstance<EventRead>({
    url: '/api/v1/events',
    method: 'POST',
    data,
    ...options,
  });
};

export const readQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: QuestionRead[] }>> => {
  return customInstance<{ data: QuestionRead[] }>({
    url: '/api/v1/questions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createQuestionApiV1QuestionsPost = (
  data: QuestionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<QuestionRead>> => {
  return customInstance<QuestionRead>({
    url: '/api/v1/questions',
    method: 'POST',
    data,
    ...options,
  });
};

export const createInteractionApiV1InteractionsPost = (
  data: InteractionCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<InteractionRead>> => {
  return customInstance<InteractionRead>({
    url: '/api/v1/interactions',
    method: 'POST',
    data,
    ...options,
  });
};

export const deleteInteractionApiV1InteractionsInteractionIdDelete = (
  interactionId: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return customInstance<void>({
    url: `/api/v1/interactions/${interactionId}`,
    method: 'DELETE',
    ...options,
  });
};

export const readInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: InteractionRead[] }>> => {
  return customInstance<{ data: InteractionRead[] }>({
    url: '/api/v1/interactions',
    method: 'GET',
    params,
    ...options,
  });
};

export const createEventParticipantApiV1EventParticipantsPost = (
  data: EventParticipantCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EventParticipantRead>> => {
  return customInstance<EventParticipantRead>({
    url: '/api/v1/event-participants',
    method: 'POST',
    data,
    ...options,
  });
};

export const readAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: AnswerRead[] }>> => {
  return customInstance<{ data: AnswerRead[] }>({
    url: '/api/v1/answers',
    method: 'GET',
    params,
    ...options,
  });
};

export const createAnswerApiV1AnswersPost = (
  data: AnswerCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnswerRead>> => {
  return customInstance<AnswerRead>({
    url: '/api/v1/answers',
    method: 'POST',
    data,
    ...options,
  });
};

export const readUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: AxiosRequestConfig
): Promise<AxiosResponse<{ data: UserRead[] }>> => {
  return customInstance<{ data: UserRead[] }>({
    url: '/api/v1/users',
    method: 'GET',
    params,
    ...options,
  });
};

export const createUserApiV1UsersPost = (
  data: UserCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UserRead>> => {
  return customInstance<UserRead>({
    url: '/api/v1/users',
    method: 'POST',
    data,
    ...options,
  });
};

// React Query hooks with enhanced error handling
export const useReadEventsApiV1EventsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: EventRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['events', params],
    queryFn: () => readEventsApiV1EventsGet(params),
    retry: (failureCount, error) => {
      // Don't retry on network errors (backend unreachable)
      if ((error as AxiosError)?.code === 'NETWORK_ERROR' || !(error as AxiosError)?.response) {
        return failureCount < 1; // Only retry once for network errors
      }
      return failureCount < 3; // Retry up to 3 times for other errors
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
    staleTime: 5 * 60 * 1000, // 5 minutes
    ...options,
  });
};

export const useReadQuestionsApiV1QuestionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: QuestionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['questions', params],
    queryFn: () => readQuestionsApiV1QuestionsGet(params),
    retry: (failureCount, error) => {
      if ((error as AxiosError)?.code === 'NETWORK_ERROR' || !(error as AxiosError)?.response) {
        return failureCount < 1;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};

export const useReadInteractionsApiV1InteractionsGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: InteractionRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['interactions', params],
    queryFn: () => readInteractionsApiV1InteractionsGet(params),
    retry: (failureCount, error) => {
      if ((error as AxiosError)?.code === 'NETWORK_ERROR' || !(error as AxiosError)?.response) {
        return failureCount < 1;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};

export const useCreateQuestionApiV1QuestionsPost = (
  options?: UseMutationOptions<AxiosResponse<QuestionRead>, Error, { data: QuestionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createQuestionApiV1QuestionsPost(data),
    ...options,
  });
};

export const useCreateInteractionApiV1InteractionsPost = (
  options?: UseMutationOptions<AxiosResponse<InteractionRead>, Error, { data: InteractionCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createInteractionApiV1InteractionsPost(data),
    ...options,
  });
};

export const useDeleteInteractionApiV1InteractionsInteractionIdDelete = (
  options?: UseMutationOptions<AxiosResponse<void>, Error, { interactionId: string }>
) => {
  return useMutation({
    mutationFn: ({ interactionId }) => deleteInteractionApiV1InteractionsInteractionIdDelete(interactionId),
    ...options,
  });
};

export const useCreateEventParticipantApiV1EventParticipantsPost = (
  options?: UseMutationOptions<AxiosResponse<EventParticipantRead>, Error, { data: EventParticipantCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventParticipantApiV1EventParticipantsPost(data),
    ...options,
  });
};

export const useCreateEventApiV1EventsPost = (
  options?: UseMutationOptions<AxiosResponse<EventRead>, Error, { data: EventCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createEventApiV1EventsPost(data),
    ...options,
  });
};

export const useCreateAnswerApiV1AnswersPost = (
  options?: UseMutationOptions<AxiosResponse<AnswerRead>, Error, { data: AnswerCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createAnswerApiV1AnswersPost(data),
    ...options,
  });
};

export const useCreateUserApiV1UsersPost = (
  options?: UseMutationOptions<AxiosResponse<UserRead>, Error, { data: UserCreate }>
) => {
  return useMutation({
    mutationFn: ({ data }) => createUserApiV1UsersPost(data),
    ...options,
  });
};

export const useReadAnswersApiV1AnswersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: AnswerRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['answers', params],
    queryFn: () => readAnswersApiV1AnswersGet(params),
    retry: (failureCount, error) => {
      if ((error as AxiosError)?.code === 'NETWORK_ERROR' || !(error as AxiosError)?.response) {
        return failureCount < 1;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};

export const useReadUsersApiV1UsersGet = (
  params?: { skip?: number; limit?: number },
  options?: UseQueryOptions<AxiosResponse<{ data: UserRead[] }>, Error>
) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => readUsersApiV1UsersGet(params),
    retry: (failureCount, error) => {
      if ((error as AxiosError)?.code === 'NETWORK_ERROR' || !(error as AxiosError)?.response) {
        return failureCount < 1;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};